# Treasure Chest
This python Treasure Chest is a password manager/overall information storage app, where users can sign up/log in to their own accounts to manage their treasure chests 
(essentially a folder), and their treasures (passwords/other information) they wish to add to their chests! Treasure Chest also has a variety of other features, such as
user authentication/authorization, CRUD operations, session functionality, and password hashing. Styled by CSS and Bootstrap, assets created by Christian Chicas.

## Technologies
This is a monolithic app that was built using python & flask to handle both the front and back ends while connecting to a Postgres database. 
Beyond this, a few python packages that help in several areas were used, such as Flask-Migrate to connect to our database, flask-sqlalchemy to create our database
models/simplify using sqlalchemy with flask, and bcrypt to hash user passwords. A full list can be found in the `requirements.txt` file.

## Setup
Setting up this app locally will require a few steps:
- Clone this repo onto your machine and open it in your code editor of choice
- Create and activate a python venv for this project
- Once in your venv, install all dependencies by running `pip install -r requirements.txt`
- Create a Postgres database to connect the app to
- Create a `_config.py` file with the following:
```
connection_string = {connection string to your Postgres database}
secret_key = {any random string}
```
- With the app now able to connect to your database, run `flask db upgrade` to migrate the initial migration file into your database
- Finally, run your app by running `flask run` or `flask run --reload`, and open the link to the app provided by flask

## Application Logic
As this app was built as a monolith project using python and flask, this app primarily relies on the back-end to perform specific functions while rendering an HTML file for the 
front-end. This of course comes with its own conditions I needed to account for, such as how to handle PUT/DELETE requests coming from an HTML form. Ultimately I came to the decision 
to send both as a POST request to the back-end and add a hidden input with either PUT or DELETE as the value for the respective action, and have the back-end update or delete data
based on that. Of course this means that traditional PUT/DELETE requests will not be accepted into the back end, but they are accounted for, allowing for the app to have CRUD
functionality for both the treasure chests and the treasures.

## Database Tables/Models & Relationships
Treasure Chest has three database tables:
- Users (One-to-many chests)
- Chests (One-to-many treasures)
- Treasures

Below is an ERD generated by Postgres:

![Database ERD](/documentation/Database%20ERD.png)

## Front-End Routes
These are all of the GET routes in this application, or every time an HTML page is rendered to the front end:

| Route | Purpose |
| ----- | ----- |
| / | Home |
| /login | Login Page |
| /signup | Sign Up Page |
| /dashboard | Dashboard once logged in (Shows all user chests + new chest form) |
| /dashboard/chests/:chest_id | Show page for a chest (Shows all treasures in a chest) |
| /dashboard/chests/:chest_id/edit | Edit page for a chest |
| /dashboard/chests/:chest_id/treasures/:treasure_id/edit | Edit page for a treasure |

## Back-End Routes
These are all of the other methods that this application's back-end handles:

| Method | Path | Purpose |
| ----- | ------ | ------ |
| POST | /login | Runs user authentication logic |
| POST | /signup | Runs first time user signup logic |
| POST | /dashboard/chests | Creates a new chest |
| POST (pseudo PUT/DELETE) | /dashboard/chests/:chest_id | Takes in method sent and updates/deletes a chest |
| POST | /dashboard/chests/:chest_id/treasures | Creates a new treasure |
| POST (pseudo PUT/DELETE) | /dashboard/chests/:chest_id/treasures/:treasures_id | Takes in method sent and updates/deletes a treasure |
| POST | /dashboard/logout | Clears user session and redirects to home |

## To-Do:
- TBD